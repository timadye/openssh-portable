Apply this patch to OpenSSH 9.3p1 and build as normal.
This will make ssh-store as well as special versions of ssh-agent, scp, and sftp
(these scp and sftp don't disable agent forwarding and don't use the new
PermitLocalCommand option that is not supported by older versions of the ssh
client - useful if scp/sftp use the system default ssh).

With CentOS7 rpm, openssh-7.4p1-22.el7_9.src.rpm, it should be possible to
build with static SSL libraries, if openssl-static rpm has been installed using:
  rpm -ba --define "static_openssl 1" SPECS/openssh.spec

Alternatively, on Linux, to make executables with static SSL libraries (libcrypto, in openssl-static rpm),
make with:

  LIBS="-Wl,-Bstatic -lcrypto -Wl,-Bdynamic -lutil -lcrypt -lresolv -ldl -lz" ./configure

(or 'make LIBS=...') or whatever configure lists as libraries (last line of summary) with
-Wl,-Bstatic before the -lcrypto and -Wl,-Bdynamic after. Note that this only works for libcrypto
(the other libraries need to be compiled with -fPIC), but that's OK as it is the
only one that changes betweek CentOS7 and Alma9.

Add SSH_PROGRAM=ssh to get scp and sftp to use ssh from the PATH, rather than
the hard-coded /usr/local/bin/ssh.

The following are instructions for compiling with OpenSSH 5.2p1 with a previous version of this patch...

I built openssh-5.2p1-store-i386_linux24.tar.bz2 on yakut02 (Scientific Linux 3.0.9) with:

cd /usr/work/adye
wget http://hepunx.rl.ac.uk/~adye/software/ssh-store4.patch
wget -N ftp://ftp.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-5.2p1.tar.gz
tar zxf openssh-5.2p1.tar.gz
cd openssh-5.2p1
patch -Zp1 < ../ssh-store4.patch
./configure
make install DESTDIR=/usr/work/adye/openssh-5.2p1-bin LIBS="-Wl,-Bstatic -lcrypto -lutil -lz -lnsl -lcrypt -lresolv -Wl,-Bdynamic" SSH_PROGRAM=ssh
cd /usr/work/adye/openssh-5.2p1-bin
find * \! -type d | tar cvjfT ../openssh-5.2p1-store-i386_linux24.tar.bz2 -

I built openssh-5.2p1-store-sun4x_510.tar.bz2 on tersk01 (SunOS 5.10) with:

wget http://hepunx.rl.ac.uk/~adye/software/ssh-store4.patch
wget -N ftp://ftp.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-5.2p1.tar.gz
gunzip openssh-5.2p1.tar.gz
tar xf openssh-5.2p1.tar
cd openssh-5.2p1
patch -p1 < ../ssh-store4.patch
./configure
make install DESTDIR=/usr/work/adye/openssh-5.2p1-bin SSH_PROGRAM=ssh
cd /usr/work/adye/openssh-5.2p1-bin
tar cf ../openssh-5.2p1-store-sun4x_510.tar `find * \! -type d`
bzip2 ../openssh-5.2p1-store-sun4x_510.tar

diff --git a/authfd.c b/authfd.c
index 25a36366..3a64d2be 100644
--- a/authfd.c
+++ b/authfd.c
@@ -52,6 +52,7 @@
 #include "xmalloc.h"
 #include "ssh.h"
 #include "sshbuf.h"
+#include "buffer.h"
 #include "sshkey.h"
 #include "authfd.h"
 #include "cipher.h"
@@ -752,3 +753,155 @@ ssh_agent_bind_hostkey(int sock, const struct sshkey *key,
 	sshbuf_free(msg);
 	return r;
 }
+
+int
+ssh_set_variable(int sock, const char *var, u_int lvar, const char *val, u_int lval)
+{
+	Buffer msg;
+	int type;
+
+	buffer_init(&msg);
+	buffer_put_char(&msg, SSH_AGENTC_SET_VARIABLE);
+  buffer_put_string(&msg, var, lvar);
+  buffer_put_string(&msg, val, lval);
+	if (ssh_request_reply(sock, &msg, &msg) != 0) {
+		buffer_free(&msg);
+		return 0;
+	}
+	type = buffer_get_char(&msg);
+	buffer_free(&msg);
+  if (type == SSH_AGENT_VARIABLE_REPLACED) return 2;
+	return decode_reply(type);
+}
+
+
+int
+ssh_get_variable(int sock, const char *var, u_int lvar, char **valp, u_int *lvalp)
+{
+	Buffer msg;
+	int ret = 0;
+	int type;
+
+  *valp= NULL;
+  if (lvalp) *lvalp= 0;
+	buffer_init(&msg);
+	buffer_put_char(&msg, SSH_AGENTC_GET_VARIABLE);
+  buffer_put_string(&msg, var, lvar);
+	if (ssh_request_reply(sock, &msg, &msg) != 0) {
+		buffer_free(&msg);
+		return 0;
+	}
+	type = buffer_get_char(&msg);
+	if (agent_failed(type)) {
+		logit("Agent could not get variable.");
+	} else if (type == SSH_AGENT_GET_VARIABLE_ANSWER) {
+		*valp = buffer_get_string(&msg, lvalp);
+		ret = 1;
+	} else if (type == SSH_AGENT_NO_VARIABLE) {
+    ret = 2;
+	} else {
+		fatal("Bad authentication response: %d", type);
+	}
+	buffer_free(&msg);
+	return ret;
+}
+
+
+/*
+ * Returns the first variable held by the agent.
+ */
+
+static int
+ssh_get_num_variables(int sock, const char *prefix, u_int lprefix, char full, Buffer *identities)
+{
+	Buffer request;
+	int type;
+  int howmany = 0;
+
+  if (!prefix) {
+    prefix = "";
+    lprefix = 0;
+  }
+	buffer_init(&request);
+	buffer_put_char(&request, full ? SSH_AGENTC_LIST_VARIABLES : SSH_AGENTC_LIST_VARIABLE_NAMES);
+  buffer_put_string(&request, prefix, lprefix);
+
+	buffer_init(identities);
+	if (ssh_request_reply(sock, &request, identities) != 0) {
+		buffer_free(&request);
+		return 0;
+	}
+	buffer_free(&request);
+
+	/* Get message type, and verify that we got a proper answer. */
+	type = buffer_get_char(identities);
+	if (agent_failed(type)) {
+		return 0;
+	} else if (type != (full ? SSH_AGENT_VARIABLES_ANSWER : SSH_AGENT_VARIABLE_NAMES_ANSWER)) {
+		fatal("Bad authentication reply message type: %d", type);
+	}
+
+	/* Get the number of entries in the response and check it for sanity. */
+	howmany = buffer_get_int(identities);
+	if ((u_int)howmany > 1024)
+		fatal("Too many variables in agent's reply: %d",
+		    howmany);
+
+	return howmany;
+}
+
+int
+ssh_get_first_variable(int sock, const char *prefix, u_int lprefix, char full,
+                       char **varp, u_int *lvarp, char **valp, u_int *lvalp,
+                       Buffer *identities, int *howmany)
+{
+	/* get number of identities and return the first entry (if any). */
+	if ((*howmany = ssh_get_num_variables(sock, prefix, lprefix, full, identities)) > 0)
+		return ssh_get_next_variable(sock, full, varp, lvarp, valp, lvalp, identities, howmany);
+	return 0;
+}
+
+int
+ssh_get_next_variable(int sock, char full,
+                      char **varp, u_int *lvarp, char **valp, u_int *lvalp,
+                      Buffer *identities, int *howmany)
+{
+  *varp = *valp = NULL;
+  *lvarp = *lvalp = 0;
+	/* Return failure if no more entries. */
+	if (*howmany <= 0)
+		return 0;
+
+	/*
+	 * Get the next entry from the packet.  These will abort with a fatal
+	 * error if the packet is too short or contains corrupt data.
+	 */
+  *varp = buffer_get_string(identities, lvarp);
+  if (full) *valp = buffer_get_string(identities, lvalp);
+	/* Decrement the number of remaining entries. */
+	(*howmany)--;
+	return 1;
+}
+
+int
+ssh_delete_variable(int sock, const char *var, u_int lvar, char all)
+{
+	Buffer msg;
+	int type;
+  if (all && !var) {
+    var = "";
+    lvar = 0;
+  }
+
+	buffer_init(&msg);
+	buffer_put_char(&msg, all ? SSH_AGENTC_REMOVE_ALL_VARIABLES : SSH_AGENTC_REMOVE_VARIABLE);
+  buffer_put_string(&msg, var, lvar);
+	if (ssh_request_reply(sock, &msg, &msg) != 0) {
+		buffer_free(&msg);
+		return 0;
+	}
+	type = buffer_get_char(&msg);
+	buffer_free(&msg);
+  if (var && type == SSH_AGENT_NO_VARIABLE) return 2;
+	return decode_reply(type);
+}
diff --git a/authfd.h b/authfd.h
index 7a1c0ddf..fae3dbab 100644
--- a/authfd.h
+++ b/authfd.h
@@ -26,6 +26,9 @@ struct ssh_identitylist {
 	char **comments;
 };
 
+struct ssh_store_buffer {
+};
+
 /* Key destination restrictions */
 struct dest_constraint_hop {
 	char *user;	/* wildcards allowed */
@@ -103,6 +106,19 @@ int	ssh_agent_bind_hostkey(int sock, const struct sshkey *key,
 /* generic extension mechanism */
 #define SSH_AGENTC_EXTENSION			27
 
+/* ssh-store commands */
+#define SSH_AGENTC_SET_VARIABLE			40
+#define SSH_AGENT_VARIABLE_REPLACED		41
+#define SSH_AGENTC_GET_VARIABLE			42
+#define SSH_AGENT_GET_VARIABLE_ANSWER		43
+#define SSH_AGENT_NO_VARIABLE			44
+#define SSH_AGENTC_LIST_VARIABLE_NAMES		45
+#define SSH_AGENT_VARIABLE_NAMES_ANSWER		46
+#define SSH_AGENTC_LIST_VARIABLES		47
+#define SSH_AGENT_VARIABLES_ANSWER		48
+#define SSH_AGENTC_REMOVE_VARIABLE		49
+#define SSH_AGENTC_REMOVE_ALL_VARIABLES		50
+
 #define	SSH_AGENT_CONSTRAIN_LIFETIME		1
 #define	SSH_AGENT_CONSTRAIN_CONFIRM		2
 #define	SSH_AGENT_CONSTRAIN_MAXSIGN		3
@@ -118,4 +134,16 @@ int	ssh_agent_bind_hostkey(int sock, const struct sshkey *key,
 #define	SSH_AGENT_RSA_SHA2_256			0x02
 #define	SSH_AGENT_RSA_SHA2_512			0x04
 
+typedef struct sshbuf Buffer;
+int
+ssh_set_variable(int, const char *, u_int, const char *, u_int);
+int
+ssh_get_variable(int, const char *, u_int, char **, u_int *);
+int
+ssh_get_first_variable(int, const char *, u_int, char, char **, u_int *, char **, u_int *, Buffer *, int *);
+int
+ssh_get_next_variable(int, char, char **, u_int *, char **, u_int *, Buffer *, int *);
+int
+ssh_delete_variable(int, const char *, u_int, char);
+
 #endif				/* AUTHFD_H */
diff --git a/bufaux.c b/bufaux.c
new file mode 100644
index 00000000..3976896a
--- /dev/null
+++ b/bufaux.c
@@ -0,0 +1,259 @@
+/* $OpenBSD: bufaux.c,v 1.60 2014/04/30 05:29:56 djm Exp $ */
+/*
+ * Copyright (c) 2012 Damien Miller <djm@mindrot.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/* Emulation wrappers for legacy OpenSSH buffer API atop sshbuf */
+
+#include "includes.h"
+
+#include <sys/types.h>
+
+#include "buffer.h"
+#include "log.h"
+#include "ssherr.h"
+
+int
+buffer_get_short_ret(u_short *v, Buffer *buffer)
+{
+	int ret;
+
+	if ((ret = sshbuf_get_u16(buffer, v)) != 0) {
+		error("%s: %s", __func__, ssh_err(ret));
+		return -1;
+	}
+	return 0;
+}
+
+u_short
+buffer_get_short(Buffer *buffer)
+{
+	u_short ret;
+
+	if (buffer_get_short_ret(&ret, buffer) == -1)
+		fatal("%s: buffer error", __func__);
+
+	return (ret);
+}
+
+int
+buffer_get_int_ret(u_int *v, Buffer *buffer)
+{
+	int ret;
+
+	if ((ret = sshbuf_get_u32(buffer, v)) != 0) {
+		error("%s: %s", __func__, ssh_err(ret));
+		return -1;
+	}
+	return 0;
+}
+
+u_int
+buffer_get_int(Buffer *buffer)
+{
+	u_int ret;
+
+	if (buffer_get_int_ret(&ret, buffer) == -1)
+		fatal("%s: buffer error", __func__);
+
+	return (ret);
+}
+
+int
+buffer_get_int64_ret(u_int64_t *v, Buffer *buffer)
+{
+	int ret;
+
+	if ((ret = sshbuf_get_u64(buffer, v)) != 0) {
+		error("%s: %s", __func__, ssh_err(ret));
+		return -1;
+	}
+	return 0;
+}
+
+u_int64_t
+buffer_get_int64(Buffer *buffer)
+{
+	u_int64_t ret;
+
+	if (buffer_get_int64_ret(&ret, buffer) == -1)
+		fatal("%s: buffer error", __func__);
+
+	return (ret);
+}
+
+void
+buffer_put_short(Buffer *buffer, u_short value)
+{
+	int ret;
+
+	if ((ret = sshbuf_put_u16(buffer, value)) != 0)
+		fatal("%s: %s", __func__, ssh_err(ret));
+}
+
+void
+buffer_put_int(Buffer *buffer, u_int value)
+{
+	int ret;
+
+	if ((ret = sshbuf_put_u32(buffer, value)) != 0)
+		fatal("%s: %s", __func__, ssh_err(ret));
+}
+
+void
+buffer_put_int64(Buffer *buffer, u_int64_t value)
+{
+	int ret;
+
+	if ((ret = sshbuf_put_u64(buffer, value)) != 0)
+		fatal("%s: %s", __func__, ssh_err(ret));
+}
+
+void *
+buffer_get_string_ret(Buffer *buffer, u_int *length_ptr)
+{
+	size_t len;
+	int ret;
+	u_char *value;
+
+	if ((ret = sshbuf_get_string(buffer, &value, &len)) != 0) {
+		error("%s: %s", __func__, ssh_err(ret));
+		return NULL;
+	}
+	if (length_ptr != NULL)
+		*length_ptr = len;  /* Safe: sshbuf never stores len > 2^31 */
+	return value;
+}
+
+void *
+buffer_get_string(Buffer *buffer, u_int *length_ptr)
+{
+	void *ret;
+
+	if ((ret = buffer_get_string_ret(buffer, length_ptr)) == NULL)
+		fatal("%s: buffer error", __func__);
+	return (ret);
+}
+
+char *
+buffer_get_cstring_ret(Buffer *buffer, u_int *length_ptr)
+{
+	size_t len;
+	int ret;
+	char *value;
+
+	if ((ret = sshbuf_get_cstring(buffer, &value, &len)) != 0) {
+		error("%s: %s", __func__, ssh_err(ret));
+		return NULL;
+	}
+	if (length_ptr != NULL)
+		*length_ptr = len;  /* Safe: sshbuf never stores len > 2^31 */
+	return value;
+}
+
+char *
+buffer_get_cstring(Buffer *buffer, u_int *length_ptr)
+{
+	char *ret;
+
+	if ((ret = buffer_get_cstring_ret(buffer, length_ptr)) == NULL)
+		fatal("%s: buffer error", __func__);
+	return ret;
+}
+
+const void *
+buffer_get_string_ptr_ret(Buffer *buffer, u_int *length_ptr)
+{
+	size_t len;
+	int ret;
+	const u_char *value;
+
+	if ((ret = sshbuf_get_string_direct(buffer, &value, &len)) != 0) {
+		error("%s: %s", __func__, ssh_err(ret));
+		return NULL;
+	}
+	if (length_ptr != NULL)
+		*length_ptr = len;  /* Safe: sshbuf never stores len > 2^31 */
+	return value;
+}
+
+const void *
+buffer_get_string_ptr(Buffer *buffer, u_int *length_ptr)
+{
+	const void *ret;
+
+	if ((ret = buffer_get_string_ptr_ret(buffer, length_ptr)) == NULL)
+		fatal("%s: buffer error", __func__);
+	return (ret);
+}
+
+void
+buffer_put_string(Buffer *buffer, const void *buf, u_int len)
+{
+	int ret;
+
+	if ((ret = sshbuf_put_string(buffer, buf, len)) != 0)
+		fatal("%s: %s", __func__, ssh_err(ret));
+}
+
+void
+buffer_put_cstring(Buffer *buffer, const char *s)
+{
+	int ret;
+
+	if ((ret = sshbuf_put_cstring(buffer, s)) != 0)
+		fatal("%s: %s", __func__, ssh_err(ret));
+}
+
+int
+buffer_get_char_ret(char *v, Buffer *buffer)
+{
+	int ret;
+
+	if ((ret = sshbuf_get_u8(buffer, (u_char *)v)) != 0) {
+		error("%s: %s", __func__, ssh_err(ret));
+		return -1;
+	}
+	return 0;
+}
+
+int
+buffer_get_char(Buffer *buffer)
+{
+	char ch;
+
+	if (buffer_get_char_ret(&ch, buffer) == -1)
+		fatal("%s: buffer error", __func__);
+	return (u_char) ch;
+}
+
+void
+buffer_put_char(Buffer *buffer, int value)
+{
+	int ret;
+
+	if ((ret = sshbuf_put_u8(buffer, value)) != 0)
+		fatal("%s: %s", __func__, ssh_err(ret));
+}
+
+void
+buffer_put_bignum2_from_string(Buffer *buffer, const u_char *s, u_int l)
+{
+	int ret;
+
+	if ((ret = sshbuf_put_bignum2_bytes(buffer, s, l)) != 0)
+		fatal("%s: %s", __func__, ssh_err(ret));
+}
+
diff --git a/buffer.c b/buffer.c
new file mode 100644
index 00000000..c5f708ab
--- /dev/null
+++ b/buffer.c
@@ -0,0 +1,118 @@
+/* $OpenBSD: buffer.c,v 1.36 2014/04/30 05:29:56 djm Exp $ */
+
+/*
+ * Copyright (c) 2012 Damien Miller <djm@mindrot.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/* Emulation wrappers for legacy OpenSSH buffer API atop sshbuf */
+
+#include "includes.h"
+
+#include <sys/types.h>
+
+#include "buffer.h"
+#include "log.h"
+#include "ssherr.h"
+
+void
+buffer_append(Buffer *buffer, const void *data, u_int len)
+{
+	int ret;
+
+	if ((ret = sshbuf_put(buffer, data, len)) != 0)
+		fatal("%s: %s", __func__, ssh_err(ret));
+}
+
+void *
+buffer_append_space(Buffer *buffer, u_int len)
+{
+	int ret;
+	u_char *p;
+
+	if ((ret = sshbuf_reserve(buffer, len, &p)) != 0)
+		fatal("%s: %s", __func__, ssh_err(ret));
+	return p;
+}
+
+int
+buffer_check_alloc(Buffer *buffer, u_int len)
+{
+	int ret = sshbuf_check_reserve(buffer, len);
+
+	if (ret == 0)
+		return 1;
+	if (ret == SSH_ERR_NO_BUFFER_SPACE)
+		return 0;
+	fatal("%s: %s", __func__, ssh_err(ret));
+}
+
+int
+buffer_get_ret(Buffer *buffer, void *buf, u_int len)
+{
+	int ret;
+
+	if ((ret = sshbuf_get(buffer, buf, len)) != 0) {
+		error("%s: %s", __func__, ssh_err(ret));
+		return -1;
+	}
+	return 0;
+}
+
+void
+buffer_get(Buffer *buffer, void *buf, u_int len)
+{
+	if (buffer_get_ret(buffer, buf, len) == -1)
+		fatal("%s: buffer error", __func__);
+}
+
+int
+buffer_consume_ret(Buffer *buffer, u_int bytes)
+{
+	int ret = sshbuf_consume(buffer, bytes);
+
+	if (ret == 0)
+		return 0;
+	if (ret == SSH_ERR_MESSAGE_INCOMPLETE)
+		return -1;
+	fatal("%s: %s", __func__, ssh_err(ret));
+}
+
+void
+buffer_consume(Buffer *buffer, u_int bytes)
+{
+	if (buffer_consume_ret(buffer, bytes) == -1)
+		fatal("%s: buffer error", __func__);
+}
+
+int
+buffer_consume_end_ret(Buffer *buffer, u_int bytes)
+{
+	int ret = sshbuf_consume_end(buffer, bytes);
+
+	if (ret == 0)
+		return 0;
+	if (ret == SSH_ERR_MESSAGE_INCOMPLETE)
+		return -1;
+	fatal("%s: %s", __func__, ssh_err(ret));
+}
+
+void
+buffer_consume_end(Buffer *buffer, u_int bytes)
+{
+	if (buffer_consume_end_ret(buffer, bytes) == -1)
+		fatal("%s: buffer error", __func__);
+}
+
+
diff --git a/buffer.h b/buffer.h
new file mode 100644
index 00000000..56174394
--- /dev/null
+++ b/buffer.h
@@ -0,0 +1,95 @@
+/* $OpenBSD: buffer.h,v 1.26 2017/04/30 23:23:54 djm Exp $ */
+
+/*
+ * Copyright (c) 2012 Damien Miller <djm@mindrot.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/* Emulation wrappers for legacy OpenSSH buffer API atop sshbuf */
+
+#ifndef BUFFER_H
+#define BUFFER_H
+
+#include "sshbuf.h"
+
+typedef struct sshbuf Buffer;
+
+#define buffer_init(b)		sshbuf_init(b)
+#define buffer_clear(b)		sshbuf_reset(b)
+#define buffer_free(b)		sshbuf_free(b)
+#define buffer_dump(b)		sshbuf_dump(b, stderr)
+
+/* XXX cast is safe: sshbuf never stores more than len 2^31 */
+#define buffer_len(b)		((u_int) sshbuf_len(b))
+#define	buffer_ptr(b)		sshbuf_mutable_ptr(b)
+
+void	 buffer_append(Buffer *, const void *, u_int);
+void	*buffer_append_space(Buffer *, u_int);
+int	 buffer_check_alloc(Buffer *, u_int);
+void	 buffer_get(Buffer *, void *, u_int);
+
+void	 buffer_consume(Buffer *, u_int);
+void	 buffer_consume_end(Buffer *, u_int);
+
+
+int	 buffer_get_ret(Buffer *, void *, u_int);
+int	 buffer_consume_ret(Buffer *, u_int);
+int	 buffer_consume_end_ret(Buffer *, u_int);
+
+#include <openssl/objects.h>
+#include <openssl/bn.h>
+void    buffer_put_bignum2(Buffer *, const BIGNUM *);
+void	buffer_get_bignum2(Buffer *, BIGNUM *);
+void	buffer_put_bignum2_from_string(Buffer *, const u_char *, u_int);
+
+u_short	buffer_get_short(Buffer *);
+void	buffer_put_short(Buffer *, u_short);
+
+u_int	buffer_get_int(Buffer *);
+void    buffer_put_int(Buffer *, u_int);
+
+u_int64_t buffer_get_int64(Buffer *);
+void	buffer_put_int64(Buffer *, u_int64_t);
+
+int     buffer_get_char(Buffer *);
+void    buffer_put_char(Buffer *, int);
+
+void   *buffer_get_string(Buffer *, u_int *);
+const void *buffer_get_string_ptr(Buffer *, u_int *);
+void    buffer_put_string(Buffer *, const void *, u_int);
+char   *buffer_get_cstring(Buffer *, u_int *);
+void	buffer_put_cstring(Buffer *, const char *);
+
+#define buffer_skip_string(b) (void)buffer_get_string_ptr(b, NULL);
+
+int	buffer_put_bignum2_ret(Buffer *, const BIGNUM *);
+int	buffer_get_bignum2_ret(Buffer *, BIGNUM *);
+int	buffer_get_short_ret(u_short *, Buffer *);
+int	buffer_get_int_ret(u_int *, Buffer *);
+int	buffer_get_int64_ret(u_int64_t *, Buffer *);
+void	*buffer_get_string_ret(Buffer *, u_int *);
+char	*buffer_get_cstring_ret(Buffer *, u_int *);
+const void *buffer_get_string_ptr_ret(Buffer *, u_int *);
+int	buffer_get_char_ret(char *, Buffer *);
+
+#ifdef OPENSSL_HAS_ECC
+#include <openssl/ec.h>
+int	buffer_put_ecpoint_ret(Buffer *, const EC_GROUP *, const EC_POINT *);
+void	buffer_put_ecpoint(Buffer *, const EC_GROUP *, const EC_POINT *);
+int	buffer_get_ecpoint_ret(Buffer *, const EC_GROUP *, EC_POINT *);
+void	buffer_get_ecpoint(Buffer *, const EC_GROUP *, EC_POINT *);
+#endif
+
+#endif	/* BUFFER_H */
+
diff --git a/Makefile.in b/Makefile.in
index 70287f51..b54b3c30 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -69,7 +69,7 @@ MKDIR_P=@MKDIR_P@
 
 .SUFFIXES: .lo
 
-TARGETS=ssh$(EXEEXT) sshd$(EXEEXT) ssh-add$(EXEEXT) ssh-keygen$(EXEEXT) ssh-keyscan${EXEEXT} ssh-keysign${EXEEXT} ssh-pkcs11-helper$(EXEEXT) ssh-agent$(EXEEXT) scp$(EXEEXT) sftp-server$(EXEEXT) sftp$(EXEEXT) ssh-sk-helper$(EXEEXT)
+TARGETS=ssh$(EXEEXT) sshd$(EXEEXT) ssh-add$(EXEEXT) ssh-store$(EXEEXT) ssh-keygen$(EXEEXT) ssh-keyscan${EXEEXT} ssh-keysign${EXEEXT} ssh-pkcs11-helper$(EXEEXT) ssh-agent$(EXEEXT) scp$(EXEEXT) sftp-server$(EXEEXT) sftp$(EXEEXT) ssh-sk-helper$(EXEEXT)
 
 XMSS_OBJS=\
 	ssh-xmss.o \
@@ -84,6 +84,8 @@ LIBOPENSSH_OBJS=\
 	ssh_api.o \
 	ssherr.o \
 	sshbuf.o \
+	buffer.o \
+	bufaux.o \
 	sshkey.o \
 	sshbuf-getput-basic.o \
 	sshbuf-misc.o \
@@ -139,6 +141,8 @@ SCP_OBJS=	scp.o progressmeter.o $(SFTP_CLIENT_OBJS)
 
 SSHADD_OBJS=	ssh-add.o $(SKOBJS)
 
+SSHSTORE_OBJS=	ssh-store.o $(SKOBJS)
+
 SSHAGENT_OBJS=	ssh-agent.o ssh-pkcs11-client.o $(SKOBJS)
 
 SSHKEYGEN_OBJS=	ssh-keygen.o sshsig.o $(SKOBJS)
@@ -215,6 +219,9 @@ scp$(EXEEXT): $(LIBCOMPAT) libssh.a $(SCP_OBJS)
 ssh-add$(EXEEXT): $(LIBCOMPAT) libssh.a $(SSHADD_OBJS)
 	$(LD) -o $@ $(SSHADD_OBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(CHANNELLIBS)
 
+ssh-store$(EXEEXT): $(LIBCOMPAT) libssh.a $(SSHSTORE_OBJS)
+	$(LD) -o $@ $(SSHSTORE_OBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(CHANNELLIBS)
+
 ssh-agent$(EXEEXT): $(LIBCOMPAT) libssh.a $(SSHAGENT_OBJS)
 	$(LD) -o $@ $(SSHAGENT_OBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(CHANNELLIBS)
 
@@ -395,6 +402,7 @@ install-files:
 	$(INSTALL) -m 0755 $(STRIP_OPT) ssh$(EXEEXT) $(DESTDIR)$(bindir)/ssh$(EXEEXT)
 	$(INSTALL) -m 0755 $(STRIP_OPT) scp$(EXEEXT) $(DESTDIR)$(bindir)/scp$(EXEEXT)
 	$(INSTALL) -m 0755 $(STRIP_OPT) ssh-add$(EXEEXT) $(DESTDIR)$(bindir)/ssh-add$(EXEEXT)
+	$(INSTALL) -m 0755 $(STRIP_OPT) ssh-store$(EXEEXT) $(DESTDIR)$(bindir)/ssh-store$(EXEEXT)
 	$(INSTALL) -m 0755 $(STRIP_OPT) ssh-agent$(EXEEXT) $(DESTDIR)$(bindir)/ssh-agent$(EXEEXT)
 	$(INSTALL) -m 0755 $(STRIP_OPT) ssh-keygen$(EXEEXT) $(DESTDIR)$(bindir)/ssh-keygen$(EXEEXT)
 	$(INSTALL) -m 0755 $(STRIP_OPT) ssh-keyscan$(EXEEXT) $(DESTDIR)$(bindir)/ssh-keyscan$(EXEEXT)
@@ -471,6 +479,7 @@ uninstall:
 	-rm -f $(DESTDIR)$(bindir)/ssh$(EXEEXT)
 	-rm -f $(DESTDIR)$(bindir)/scp$(EXEEXT)
 	-rm -f $(DESTDIR)$(bindir)/ssh-add$(EXEEXT)
+	-rm -f $(DESTDIR)$(bindir)/ssh-store$(EXEEXT)
 	-rm -f $(DESTDIR)$(bindir)/ssh-agent$(EXEEXT)
 	-rm -f $(DESTDIR)$(bindir)/ssh-keygen$(EXEEXT)
 	-rm -f $(DESTDIR)$(bindir)/ssh-keyscan$(EXEEXT)
diff --git a/scp.c b/scp.c
index a893d4a2..54b8f58b 100644
--- a/scp.c
+++ b/scp.c
@@ -499,7 +499,6 @@ main(int argc, char **argv)
 	args.list = remote_remote_args.list = NULL;
 	addargs(&args, "%s", ssh_program);
 	addargs(&args, "-x");
-	addargs(&args, "-oPermitLocalCommand=no");
 	addargs(&args, "-oClearAllForwardings=yes");
 	addargs(&args, "-oRemoteCommand=none");
 	addargs(&args, "-oRequestTTY=no");
diff --git a/sftp.c b/sftp.c
index 29081db3..c99356bf 100644
--- a/sftp.c
+++ b/sftp.c
@@ -2441,7 +2441,6 @@ main(int argc, char **argv)
 	args.list = NULL;
 	addargs(&args, "%s", ssh_program);
 	addargs(&args, "-oForwardX11 no");
-	addargs(&args, "-oPermitLocalCommand no");
 	addargs(&args, "-oClearAllForwardings yes");
 
 	ll = SYSLOG_LEVEL_INFO;
diff --git a/ssh-agent.c b/ssh-agent.c
index 618bb198..5cd22810 100644
--- a/ssh-agent.c
+++ b/ssh-agent.c
@@ -78,6 +78,7 @@
 #include "ssh.h"
 #include "ssh2.h"
 #include "sshbuf.h"
+#include "buffer.h"
 #include "sshkey.h"
 #include "authfd.h"
 #include "log.h"
@@ -153,6 +154,21 @@ struct idtable {
 /* private key table */
 struct idtable *idtab;
 
+typedef struct variable {
+	TAILQ_ENTRY(variable) next;
+	char *var;
+	char *val;
+	u_int lvar;
+	u_int lval;
+} Variable;
+
+typedef struct {
+	int nentries;
+	TAILQ_HEAD(varqueue, variable) varlist;
+} Vartab;
+
+Vartab vartable;
+
 int max_fd = 0;
 
 /* pid of shell == parent of agent */
@@ -229,6 +245,13 @@ free_dest_constraint_hop(struct dest_constraint_hop *dch)
 	free(dch->key_is_ca);
 }
 
+static void
+vartab_init(void)
+{
+  TAILQ_INIT(&vartable.varlist);
+  vartable.nentries = 0;
+}
+
 static void
 free_dest_constraints(struct dest_constraint *dcs, size_t ndcs)
 {
@@ -463,6 +486,14 @@ identity_permitted(Identity *id, SocketEntry *e, char *user,
 	return 0;
 }
 
+static void
+free_variable(Variable *v)
+{
+  free(v->var);
+  free(v->val);
+	free(v);
+}
+
 /* return matching private key for given public key */
 static Identity *
 lookup_identity(struct sshkey *key)
@@ -1565,6 +1596,186 @@ process_ext_session_bind(SocketEntry *e)
 	sshbuf_free(sig);
 	return r == 0 ? 1 : 0;
 }
+/* return variable entry for given name */
+static Variable *
+lookup_variable(const char *var, u_int lvar)
+{
+	Variable *v;
+
+	TAILQ_FOREACH(v, &vartable.varlist, next) {
+		if (lvar == v->lvar && 0 == memcmp(var, v->var, lvar))
+      return (v);
+	}
+	return (NULL);
+}
+
+
+static void
+process_set_variable(SocketEntry *e)
+{
+	u_int lvar, lval;
+	char *var, *val;
+  Variable *v;
+  int replace = 0;
+
+  var= buffer_get_string(e->request, &lvar);
+  val= buffer_get_string(e->request, &lval);
+
+  if ((v = lookup_variable(var, lvar))) {
+    debug("set '%.*s' = '%.*s' (replacing old value '%.*s')", lvar, var, lval, val, v->lval, v->val);
+    free(var);
+    free(v->val);
+    replace = 1;
+  } else {
+    debug("set '%.*s' = '%.*s'", lvar, var, lval, val);
+    v = xmalloc(sizeof(Variable));
+    v->var = var;
+    v->lvar = lvar;
+    TAILQ_INSERT_TAIL(&vartable.varlist, v, next);
+    vartable.nentries++;
+  }
+  v->val = val;
+  v->lval = lval;
+	buffer_put_int(e->output, 1);
+	buffer_put_char(e->output, replace ? SSH_AGENT_VARIABLE_REPLACED : SSH_AGENT_SUCCESS);
+}
+
+
+static void
+process_get_variable(SocketEntry *e)
+{
+	u_int lvar;
+	char *var;
+  Variable *v;
+	Buffer msg;
+
+  var= buffer_get_string(e->request, &lvar);
+
+	buffer_init(&msg);
+  if ((v = lookup_variable(var, lvar))) {
+    debug("get '%.*s' -> '%.*s'", lvar, var, v->lval, v->val);
+    buffer_put_char(&msg, SSH_AGENT_GET_VARIABLE_ANSWER);
+    buffer_put_string(&msg, v->val, v->lval);
+  } else {
+    debug("variable '%.*s' not found", lvar, var);
+    buffer_put_char(&msg, SSH_AGENT_NO_VARIABLE);
+  }
+  free(var);
+	buffer_put_int(e->output, buffer_len(&msg));
+	buffer_append(e->output, buffer_ptr(&msg), buffer_len(&msg));
+	buffer_free(&msg);
+}
+
+/* send list of variables */
+static void
+process_list_variables(SocketEntry *e, char full)
+{
+	Buffer msg, msg2;
+  char *prefix;
+  u_int lprefix, nret = 0;
+  Variable *v;
+
+  prefix= buffer_get_string(e->request, &lprefix);
+	buffer_init(&msg);
+	TAILQ_FOREACH(v, &vartable.varlist, next) {
+    if (lprefix == 0 || (v->lvar >= lprefix && 0 == memcmp (v->var, prefix, lprefix))) {
+      buffer_put_string(&msg, v->var, v->lvar);
+      if (full) buffer_put_string(&msg, v->val, v->lval);
+      nret++;
+    }
+	}
+  free(prefix);
+	buffer_init(&msg2);
+	buffer_put_char(&msg2, full ?
+	    SSH_AGENT_VARIABLES_ANSWER : SSH_AGENT_VARIABLE_NAMES_ANSWER);
+	buffer_put_int(&msg2, nret);
+	buffer_put_int(e->output, buffer_len(&msg)+buffer_len(&msg2));
+	buffer_append(e->output, buffer_ptr(&msg2), buffer_len(&msg2));
+	buffer_append(e->output, buffer_ptr(&msg), buffer_len(&msg));
+	buffer_free(&msg);
+}
+
+static void
+no_variables(SocketEntry *e, u_int type)
+{
+	Buffer msg;
+
+	buffer_init(&msg);
+	buffer_put_char(&msg,
+	    (type == SSH_AGENTC_LIST_VARIABLES) ?
+	    SSH_AGENT_VARIABLES_ANSWER : SSH_AGENT_VARIABLE_NAMES_ANSWER);
+	buffer_put_int(&msg, 0);
+	buffer_put_int(e->output, buffer_len(&msg));
+	buffer_append(e->output, buffer_ptr(&msg), buffer_len(&msg));
+	buffer_free(&msg);
+}
+
+/* shared */
+static void
+process_remove_variable(SocketEntry *e)
+{
+	int success = 0;
+	u_int lvar;
+	char *var;
+  Variable *v;
+
+  var= buffer_get_string(e->request, &lvar);
+
+  if ((v = lookup_variable(var, lvar))) {
+    /*
+     * We have this key.  Free the old key.  Since we
+     * don't want to leave empty slots in the middle of
+     * the array, we actually free the key there and move
+     * all the entries between the empty slot and the end
+     * of the array.
+     */
+    if (vartable.nentries < 1)
+      fatal("process_remove_identity: "
+				    "internal error: vartable.nentries %d",
+				    vartable.nentries);
+    TAILQ_REMOVE(&vartable.varlist, v, next);
+    free_variable (v);
+    vartable.nentries--;
+    success = 1;
+	}
+  free (var);
+	buffer_put_int(e->output, 1);
+	buffer_put_char(e->output,
+	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_NO_VARIABLE);
+}
+
+static void
+process_remove_all_variables(SocketEntry *e)
+{
+  char *prefix;
+  u_int lprefix, ndel = 0;
+  Variable *v, *last = NULL;
+
+  prefix= buffer_get_string(e->request, &lprefix);
+	TAILQ_FOREACH(v, &vartable.varlist, next) {
+    if (last) {   /* don't remove variable until we've moved past it */
+      TAILQ_REMOVE(&vartable.varlist, last, next);
+      free_variable (last);
+      last = NULL;
+    }
+    if (lprefix == 0 || (v->lvar >= lprefix && 0 == memcmp (v->var, prefix, lprefix))) {
+      vartable.nentries--;
+      ndel++;
+      last = v;
+    }
+	}
+  if (last) {
+    TAILQ_REMOVE(&vartable.varlist, last, next);
+    free_variable (last);
+  }
+  free(prefix);
+
+	/* Send success. */
+	buffer_put_int(e->output, 1);
+	buffer_put_char(e->output, ndel ? SSH_AGENT_SUCCESS : SSH_AGENT_NO_VARIABLE);
+}
+
+/* dispatch incoming messages */
 
 static void
 process_extension(SocketEntry *e)
@@ -1636,6 +1847,10 @@ process_message(u_int socknum)
 			/* send empty lists */
 			no_identities(e);
 			break;
+    case SSH_AGENTC_LIST_VARIABLE_NAMES:
+    case SSH_AGENTC_LIST_VARIABLES:
+      no_variables(e, type);
+      break;
 		default:
 			/* send a fail message for all other request types */
 			send_status(e, 0);
@@ -1680,6 +1895,24 @@ process_message(u_int socknum)
 	case SSH_AGENTC_EXTENSION:
 		process_extension(e);
 		break;
+	case SSH_AGENTC_SET_VARIABLE:
+		process_set_variable(e);
+		break;
+	case SSH_AGENTC_GET_VARIABLE:
+		process_get_variable(e);
+		break;
+	case SSH_AGENTC_LIST_VARIABLE_NAMES:
+		process_list_variables(e, 0);
+		break;
+	case SSH_AGENTC_LIST_VARIABLES:
+		process_list_variables(e, 1);
+		break;
+	case SSH_AGENTC_REMOVE_VARIABLE:
+		process_remove_variable(e);
+		break;
+	case SSH_AGENTC_REMOVE_ALL_VARIABLES:
+		process_remove_all_variables(e);
+		break;
 	default:
 		/* Unknown message.  Respond with failure. */
 		error("Unknown message %d", type);
@@ -2242,7 +2475,9 @@ skip:
 	new_socket(AUTH_SOCKET, sock);
 	if (ac > 0)
 		parent_alive_interval = 10;
+
 	idtab_init();
+	vartab_init();
 	ssh_signal(SIGPIPE, SIG_IGN);
 	ssh_signal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);
 	ssh_signal(SIGHUP, cleanup_handler);
diff --git a/sshbuf.c b/sshbuf.c
index d7f4e4ab..7dc58c37 100644
--- a/sshbuf.c
+++ b/sshbuf.c
@@ -39,18 +39,6 @@
 # define SSHBUF_TELL(what)
 #endif
 
-struct sshbuf {
-	u_char *d;		/* Data */
-	const u_char *cd;	/* Const data */
-	size_t off;		/* First available byte is buf->d + buf->off */
-	size_t size;		/* Last byte is buf->d + buf->size - 1 */
-	size_t max_size;	/* Maximum size of buffer */
-	size_t alloc;		/* Total bytes allocated to buf->d */
-	int readonly;		/* Refers to external, const data */
-	u_int refcount;		/* Tracks self and number of child buffers */
-	struct sshbuf *parent;	/* If child, pointer to parent */
-};
-
 static inline int
 sshbuf_check_sanity(const struct sshbuf *buf)
 {
@@ -59,6 +47,7 @@ sshbuf_check_sanity(const struct sshbuf *buf)
 	    (!buf->readonly && buf->d != buf->cd) ||
 	    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||
 	    buf->cd == NULL ||
+	    (buf->dont_free && (buf->readonly || buf->parent != NULL)) ||
 	    buf->max_size > SSHBUF_SIZE_MAX ||
 	    buf->alloc > buf->max_size ||
 	    buf->size > buf->alloc ||
@@ -158,6 +147,8 @@ sshbuf_fromb(struct sshbuf *buf)
 void
 sshbuf_free(struct sshbuf *buf)
 {
+	int dont_free = 0;
+
 	if (buf == NULL)
 		return;
 	/*
@@ -178,6 +169,8 @@ sshbuf_free(struct sshbuf *buf)
 	if (buf->refcount > 0)
 		return;
 
+	dont_free = buf->dont_free;
+
 	/*
 	 * If we are a child, the free our parent to decrement its reference
 	 * count and possibly free it.
@@ -189,7 +182,21 @@ sshbuf_free(struct sshbuf *buf)
 		explicit_bzero(buf->d, buf->alloc);
 		free(buf->d);
 	}
-	freezero(buf, sizeof(*buf));
+	if (!dont_free)
+		freezero(buf, sizeof(*buf));
+}
+
+void
+sshbuf_init(struct sshbuf *ret)
+{
+	explicit_bzero(ret, sizeof(*ret));
+	ret->alloc = SSHBUF_SIZE_INIT;
+	ret->max_size = SSHBUF_SIZE_MAX;
+	ret->readonly = 0;
+	ret->dont_free = 1;
+	ret->refcount = 1;
+	if ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL)
+		ret->alloc = 0;
 }
 
 void
diff --git a/sshbuf.h b/sshbuf.h
index e2155f9a..8ee7f63a 100644
--- a/sshbuf.h
+++ b/sshbuf.h
@@ -33,7 +33,29 @@
 #define SSHBUF_MAX_BIGNUM	(16384 / 8)	/* Max bignum *bytes* */
 #define SSHBUF_MAX_ECPOINT	((528 * 2 / 8) + 1) /* Max EC point *bytes* */
 
-struct sshbuf;
+/*
+ * NB. do not depend on the internals of this. It will be made opaque
+ * one day.
+ */
+struct sshbuf {
+	u_char *d;		/* Data */
+	const u_char *cd;	/* Const data */
+	size_t off;		/* First available byte is buf->d + buf->off */
+	size_t size;		/* Last byte is buf->d + buf->size - 1 */
+	size_t max_size;	/* Maximum size of buffer */
+	size_t alloc;		/* Total bytes allocated to buf->d */
+	int readonly;		/* Refers to external, const data */
+	int dont_free;		/* Kludge to support sshbuf_init */
+	u_int refcount;		/* Tracks self and number of child buffers */
+	struct sshbuf *parent;	/* If child, pointer to parent */
+};
+
+/*
+ * NB. Please do not use sshbuf_init() in new code. Please use sshbuf_new()
+ * instead. sshbuf_init() is deprecated and will go away soon (it is
+ * only included to allow compat with buffer_* in OpenSSH)
+ */
+void sshbuf_init(struct sshbuf *buf);
 
 /*
  * Create a new sshbuf buffer.
diff --git a/ssh-store.c b/ssh-store.c
new file mode 100644
index 00000000..713ffd68
--- /dev/null
+++ b/ssh-store.c
@@ -0,0 +1,253 @@
+/* $OpenBSD: ssh-store.c,v 1.89 2006/08/03 03:34:42 deraadt Exp $ */
+/*
+ * ssh-store.c by Tim Adye <T.J.Adye@rl.ac.uk>, based on ssh-add.c.
+ *
+ * ssh-add.c:-
+ * Author: Tatu Ylonen <ylo@cs.hut.fi>
+ * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
+ *                    All rights reserved
+ * Adds an identity to the authentication server, or removes an identity.
+ *
+ * As far as I am concerned, the code I have written for this software
+ * can be used freely for any purpose.  Any derived versions of this
+ * software must be clearly marked as such, and if the derived work is
+ * incompatible with the protocol description in the RFC file, it must be
+ * called by a name other than "ssh" or "Secure Shell".
+ *
+ * SSH2 implementation,
+ * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "includes.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <openssl/evp.h>
+
+#include <fcntl.h>
+#include <pwd.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "xmalloc.h"
+#include "ssh.h"
+#include "log.h"
+#include "sshkey.h"
+#include "sshbuf.h"
+#include "authfd.h"
+#include "authfile.h"
+#include "pathnames.h"
+#include "misc.h"
+#include "ssherr.h"
+#include "digest.h"
+
+/* argv0 */
+extern char *__progname;
+#define CHUNK 1024
+
+int
+set_from_file(int agent_fd, const char *var, u_int lvar, const char *file)
+{
+  FILE *f;
+  char *val = NULL;
+  u_int lval = 0;
+  size_t n;
+  int ret;
+
+  if (file && 0 != strcmp (file, "-")) {
+    f = fopen (file, "r");
+    if (!f) {
+      fprintf (stderr, "%s: could not open %s\n", __progname, file);
+      return 3;
+    }
+  } else {
+    f = stdin;
+  }
+  lval = 0;
+  do {
+    val= xreallocarray (val, lval+CHUNK, 1);
+    n = fread (val+lval, 1, CHUNK, f);
+    lval += n;
+  } while (n == CHUNK);
+  ret = ssh_set_variable (agent_fd, var, lvar, val, lval);
+  free (val);
+  return ret;
+}
+
+static int
+print_variable(int agent_fd, const char *var, u_int lvar)
+{
+  int ret = 0;
+  char *val;
+  u_int lval;
+
+  ret = ssh_get_variable(agent_fd, var, lvar, &val, &lval);
+  if (ret && val) {
+    fwrite (val, 1, lval, stdout);
+    free(val);
+  }
+  return ret;
+}
+
+static int
+list_variables(int agent_fd, const char* prefix, u_int lprefix, char full)
+{
+  char *var, *val;
+  u_int lvar, lval;
+  int ok, nvars = 0;
+  Buffer identities;
+  int howmany = 0;
+
+  for (ok = ssh_get_first_variable(agent_fd, prefix, lprefix, full, &var, &lvar, &val, &lval, &identities, &howmany);
+       ok;
+       ok = ssh_get_next_variable(agent_fd, full, &var, &lvar, &val, &lval, &identities, &howmany)) {
+    fwrite (var, 1, lvar, stdout);
+    if (full && val) {
+      putchar (' ');
+      fwrite (val, 1, lval, stdout);
+      if (!(lval > 0 && val[lval-1] == '\n')) putchar ('\n');
+    } else {
+      putchar ('\n');
+    }
+    free(var);
+    if (val) free(val);
+    nvars++;
+  }
+  return (nvars==0 ? 2 : 1);
+}
+
+static void
+usage(void)
+{
+  fprintf(stderr, "Usage: %s [options] variable [value]\n", __progname);
+  fprintf(stderr, "Options:\n");
+  fprintf(stderr, "  -s          Set variable (default if value specified).\n");
+  fprintf(stderr, "  -f          Set value from a file (specified as second argument, or else stdin).\n");
+  fprintf(stderr, "  -g          Get variable value (default if value not specified).\n");
+  fprintf(stderr, "  -l          List stored variables.\n");
+  fprintf(stderr, "  -L          List stored variables and their values (may include binary values)\n");
+  fprintf(stderr, "  -d          Delete stored value.\n");
+  fprintf(stderr, "  -D          Delete all stored values.\n");
+}
+
+int
+main(int argc, char **argv)
+{
+  extern int optind;
+  int agent_fd;
+  int r, ch, set = 0, get = 0, list = 0, delete = 0, ret = 0;
+
+  /* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
+  sanitise_stdfd();
+
+  __progname = ssh_get_progname(argv[0]);
+
+  /* First, get a connection to the authentication agent. */
+  switch (r = ssh_get_authentication_socket(&agent_fd)) {
+  case 0:
+    break;
+  case SSH_ERR_AGENT_NOT_PRESENT:
+    fprintf(stderr, "Could not open a connection to your "
+        "authentication agent.\n");
+    exit(2);
+  default:
+    fprintf(stderr, "Error connecting to agent: %s\n", ssh_err(r));
+    exit(2);
+  }
+  while ((ch = getopt(argc, argv, "hsfglLdD")) != -1) {
+    switch (ch) {
+    case 's':
+      set = 1;
+      break;
+    case 'f':
+      set = 2;
+      break;
+    case 'g':
+      get = 1;
+      break;
+    case 'l':
+      list = 1;
+      break;
+    case 'L':
+      list = 2;
+      break;
+    case 'd':
+      delete = 1;
+      break;
+    case 'D':
+      delete = 2;
+      break;
+    default:
+      usage();
+      ret = 2;
+      goto done;
+    }
+  }
+  argc -= optind;
+  argv += optind;
+
+  if ((set == 1 && argc != 2) ||
+      (set == 2 && (argc < 1 || argc > 2)) ||
+      ((get || delete == 1) && argc != 1) ||
+      ((list || delete == 2) && argc > 1) ||
+      ((!!set)+(!!get)+(!!list)+(!!delete) > 1)) {
+    fprintf (stderr, "%s: bad options\n", __progname);
+    goto done;
+  }
+  if (!(set || get || list || delete)) {
+    if      (argc == 1) get = 1;
+    else if (argc == 2) set = 1;
+    else {
+      usage();
+      goto done;
+    }
+  }
+
+  if        (set == 2) {
+    ret = set_from_file       (agent_fd, argv[0], strlen(argv[0]), (argc >= 2 ? argv[1] : NULL));
+  } else if (set) {
+    ret = ssh_set_variable    (agent_fd, argv[0], strlen(argv[0]), argv[1], strlen(argv[1]));
+  } else if (get) {
+    ret = print_variable      (agent_fd, argv[0], strlen(argv[0]));
+  } else if (list) {
+    if (argc >= 1) {
+      ret = list_variables      (agent_fd, argv[0], strlen(argv[0]), (list==2));
+    } else {
+      ret = list_variables      (agent_fd, "",      0,               (list==2));
+    }
+  } else if (delete) {
+    if (argc >= 1) {
+      ret = ssh_delete_variable (agent_fd, argv[0], strlen(argv[0]), (delete==2));
+    } else {
+      ret = ssh_delete_variable (agent_fd, "",      0,               (delete==2));
+    }
+  }
+  
+done:
+  ssh_close_authentication_socket(agent_fd);
+  return (ret > 0 ? ret-1 : 10);
+}
